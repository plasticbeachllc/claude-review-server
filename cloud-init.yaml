#cloud-config
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# PR Review Agent â€” Hetzner cloud-init
#
# GENERATED FILE â€” do not edit directly.
# Edit the source files and run: just build
#
# POST-PROVISION STEPS (do these manually after first boot):
#   1. Place Cloudflare Origin CA cert + key:
#        /etc/caddy/certs/origin.pem
#        /etc/caddy/certs/origin-key.pem
#      Then: sudo systemctl restart caddy
#
#   2. Authenticate the review user:
#        sudo -u review gh auth login          # GitHub OAuth
#        sudo -u review claude                  # Claude subscription login
#
#   3. Edit /opt/pr-review/.env and set:
#        ALERT_REPO=your-org/your-repo          # for auth-expiry alerts
#        GITHUB_WEBHOOK_SECRET=<from GitHub>     # or keep the generated one
#
#   4. Configure an org-level webhook in GitHub:
#        URL:    https://your-domain.com/webhook
#        Secret: (value from /opt/pr-review/.env)
#        Events: Pull requests
#
#   5. Start the service:
#        sudo systemctl start pr-review
#        sudo systemctl start pr-review-auth-check.timer
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

package_update: true
package_upgrade: true

packages:
  - python3
  - git
  - jq
  - ufw
  - debian-keyring
  - debian-archive-keyring
  - apt-transport-https
  - curl

write_files:
  # â”€â”€ Main agent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - path: /opt/pr-review/agent.py
    permissions: "0755"
    content: |
      #!/usr/bin/env python3
      """GitHub PR Review Agent â€” webhook listener + Claude CLI reviewer."""

      import hashlib
      import hmac
      import json
      import logging
      import os
      import re
      import shlex
      import subprocess
      import sys
      from concurrent.futures import ThreadPoolExecutor
      from http.server import HTTPServer, BaseHTTPRequestHandler
      from pathlib import Path

      # â”€â”€ Structured JSON logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      class JSONFormatter(logging.Formatter):
          def format(self, record):
              entry = {
                  "ts": self.formatTime(record),
                  "level": record.levelname,
                  "msg": record.getMessage(),
              }
              if record.exc_info and record.exc_info[0]:
                  entry["exc"] = self.formatException(record.exc_info)
              return json.dumps(entry)

      handler = logging.StreamHandler(sys.stdout)
      handler.setFormatter(JSONFormatter())
      logging.root.handlers = [handler]
      logging.root.setLevel(logging.INFO)
      log = logging.getLogger("pr-review")

      # â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      WEBHOOK_SECRET = os.environ["GITHUB_WEBHOOK_SECRET"]  # tests must set before import
      WORKDIR = Path(os.environ.get("REVIEW_WORKDIR", "/opt/pr-review/workspace"))
      MAX_WORKERS = int(os.environ.get("MAX_WORKERS", "4"))
      REVIEW_MARKER = "<!-- claude-review -->"
      SCRIPT_DIR = Path(__file__).resolve().parent
      _prompt_template: str | None = None


      def get_prompt_template() -> str:
          """Lazy-load the prompt template on first use."""
          global _prompt_template
          if _prompt_template is None:
              _prompt_template = (SCRIPT_DIR / "prompt.md").read_text()
          return _prompt_template

      # Files to drop first when truncating large diffs
      LOW_PRIORITY_PATTERNS = [
          r"(package-lock|yarn\.lock|pnpm-lock|Cargo\.lock|go\.sum|composer\.lock)",
          r"\.(generated|min)\.(js|css|ts)$",
          r"__snapshots__/",
          r"\.svg$",
          r"vendor/",
          r"\.pb\.go$",
      ]

      executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)

      # â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      def verify_signature(payload: bytes, signature: str) -> bool:
          """Verify GitHub HMAC-SHA256 webhook signature."""
          if not signature.startswith("sha256="):
              return False
          expected = "sha256=" + hmac.new(
              WEBHOOK_SECRET.encode(), payload, hashlib.sha256
          ).hexdigest()
          return hmac.compare_digest(expected, signature)


      def is_low_priority(filename: str) -> bool:
          """Check if a file matches low-priority patterns (lockfiles, generated, vendor, etc.)."""
          return any(re.search(p, filename) for p in LOW_PRIORITY_PATTERNS)


      def smart_truncate_diff(diff: str, max_chars: int = 40_000) -> tuple[str, str]:
          """Truncate diff by dropping low-priority files first, then large files."""
          if len(diff) <= max_chars:
              return diff, ""

          # Split diff into per-file chunks
          file_diffs = []
          current = []
          current_name = ""
          for line in diff.splitlines(keepends=True):
              if line.startswith("diff --git"):
                  if current:
                      file_diffs.append((current_name, "".join(current)))
                  current = [line]
                  # Extract filename from "diff --git a/path b/path"
                  parts = shlex.split(line)
                  current_name = parts[-1][2:] if len(parts) >= 4 else "unknown"
              else:
                  current.append(line)
          if current:
              file_diffs.append((current_name, "".join(current)))

          # Sort: high-priority files first (is_low_priority=False sorts before True),
          # then by size ascending within each group (keep smaller files, drop bigger ones)
          file_diffs.sort(key=lambda x: (is_low_priority(x[0]), len(x[1])))

          kept = []
          dropped = []
          total = 0
          for name, content in file_diffs:
              if total + len(content) <= max_chars:
                  kept.append(content)
                  total += len(content)
              else:
                  dropped.append(name)

          note = ""
          if dropped:
              note = (
                  f"\n\n(Diff truncated for review. {len(dropped)} file(s) omitted: "
                  f"{', '.join(dropped[:10])}"
                  f"{'...' if len(dropped) > 10 else ''})"
              )
          return "".join(kept), note


      def already_reviewed(repo: str, pr_number: int) -> bool:
          """Check if we already posted a review comment on this PR."""
          result = subprocess.run(
              ["gh", "pr", "view", str(pr_number), "--repo", repo,
               "--json", "comments", "--jq",
               '[.comments[].body | select(contains("<!-- claude-review -->"))] '
               '| length'],
              capture_output=True, text=True, timeout=30,
          )
          try:
              return int(result.stdout.strip()) > 0
          except (ValueError, AttributeError):
              return False


      def collapse_old_reviews(repo: str, pr_number: int):
          """Edit previous review comments to collapse them under a <details> tag."""
          result = subprocess.run(
              ["gh", "api",
               f"/repos/{repo}/issues/{pr_number}/comments",
               "--paginate", "--jq",
               '.[] | select(.body | contains("<!-- claude-review -->")) '
               '| select(.body | contains("<details>") | not) '
               '| {id: .id, body: .body}'],
              capture_output=True, text=True, timeout=30,
          )
          if result.returncode != 0 or not result.stdout.strip():
              return

          for line in result.stdout.strip().splitlines():
              try:
                  comment = json.loads(line)
                  comment_id = comment.get("id")
                  old_body = comment.get("body")
              except (json.JSONDecodeError, AttributeError):
                  continue

              if not comment_id or not old_body:
                  continue

              # Wrap in collapsed details
              collapsed = (
                  f"{REVIEW_MARKER}\n"
                  f"<details>\n<summary>Previous review (superseded)</summary>\n\n"
                  f"{old_body.replace(REVIEW_MARKER, '').strip()}\n\n"
                  f"</details>"
              )
              subprocess.run(
                  ["gh", "api", "--method", "PATCH",
                   f"/repos/{repo}/issues/comments/{comment_id}",
                   "-f", f"body={collapsed}"],
                  capture_output=True, timeout=30,
              )


      def review_pr(repo: str, pr_number: int, pr_title: str, action: str):
          """Fetch diff, invoke Claude, post review comment."""
          log.info(f"Reviewing {repo}#{pr_number}: {pr_title} ({action})")
          try:
              if action == "opened" and already_reviewed(repo, pr_number):
                  log.info(f"Already reviewed {repo}#{pr_number}, skipping")
                  return

              # Collapse old reviews on force-push
              if action == "synchronize":
                  collapse_old_reviews(repo, pr_number)

              diff_result = subprocess.run(
                  ["gh", "pr", "diff", str(pr_number), "--repo", repo],
                  capture_output=True, text=True, timeout=60,
              )
              if diff_result.returncode != 0:
                  log.error(f"gh pr diff failed: {diff_result.stderr}")
                  return

              body_result = subprocess.run(
                  ["gh", "pr", "view", str(pr_number), "--repo", repo,
                   "--json", "body", "--jq", ".body"],
                  capture_output=True, text=True, timeout=30,
              )
              pr_body = body_result.stdout.strip() if body_result.returncode == 0 else ""

              diff, truncation_note = smart_truncate_diff(diff_result.stdout)

              if not diff.strip():
                  log.warning(f"Empty diff for {repo}#{pr_number}")
                  return

              prompt = get_prompt_template().format(
                  pr_number=pr_number,
                  repo=repo,
                  pr_title=pr_title,
                  pr_body=pr_body or "(none)",
                  truncation_note=truncation_note,
                  diff=diff,
              )

              result = subprocess.run(
                  ["claude", "-p", prompt, "--output-format", "text"],
                  capture_output=True, text=True, timeout=300,
                  cwd=str(WORKDIR),
              )
              if result.returncode != 0:
                  log.error(f"claude failed (exit {result.returncode}): {result.stderr}")
                  return

              review_text = result.stdout.strip()
              if not review_text:
                  log.warning("Empty review output")
                  return

              header = "ğŸ”„ Updated Review" if action == "synchronize" else "ğŸ“ Review"
              comment = (
                  f"{REVIEW_MARKER}\n"
                  f"## {header}\n\n"
                  f"{review_text}\n\n"
                  f"---\n"
                  f"*Automated review by Claude Code*"
              )

              post_result = subprocess.run(
                  ["gh", "pr", "comment", str(pr_number), "--repo", repo,
                   "--body", comment],
                  capture_output=True, text=True, timeout=30,
              )
              if post_result.returncode != 0:
                  log.error(f"Failed to post comment: {post_result.stderr}")
                  return

              log.info(f"Posted review for {repo}#{pr_number}")

          except subprocess.TimeoutExpired:
              log.error(f"Timeout reviewing {repo}#{pr_number}")
          except Exception as e:
              log.error(f"Error reviewing {repo}#{pr_number}: {e}", exc_info=True)


      # â”€â”€ HTTP handler â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      class WebhookHandler(BaseHTTPRequestHandler):
          def do_POST(self):
              if self.path != "/webhook":
                  self.send_response(404)
                  self.end_headers()
                  return

              length = int(self.headers.get("Content-Length", 0))
              if length > 5_000_000:  # 5 MB sanity limit
                  log.warning(f"Payload too large ({length} bytes) from {self.client_address[0]}")
                  self.send_response(413)
                  self.end_headers()
                  return

              payload = self.rfile.read(length)
              signature = self.headers.get("X-Hub-Signature-256", "")

              if not verify_signature(payload, signature):
                  log.warning(f"Invalid signature from {self.client_address[0]}")
                  self.send_response(403)
                  self.end_headers()
                  return

              self.send_response(200)
              self.end_headers()
              self.wfile.write(b'{"ok":true}')

              event = self.headers.get("X-GitHub-Event", "")
              if event != "pull_request":
                  return

              data = json.loads(payload)
              action = data.get("action")
              if action not in ("opened", "synchronize"):
                  return

              pr = data["pull_request"]
              if pr.get("draft", False):
                  log.info(f"Skipping draft PR #{pr['number']}")
                  return

              executor.submit(
                  review_pr,
                  data["repository"]["full_name"],
                  pr["number"],
                  pr["title"],
                  action,
              )

          def do_GET(self):
              if self.path == "/health":
                  self.send_response(200)
                  self.end_headers()
                  self.wfile.write(b'{"status":"healthy"}')
              else:
                  self.send_response(404)
                  self.end_headers()

          def log_message(self, fmt, *args):
              log.info(f"{self.client_address[0]} {fmt % args}")


      if __name__ == "__main__":
          WORKDIR.mkdir(parents=True, exist_ok=True)
          port = int(os.environ.get("PORT", "8080"))
          server = HTTPServer(("127.0.0.1", port), WebhookHandler)
          log.info(f"PR Review Agent listening on 127.0.0.1:{port} "
                   f"(workers={MAX_WORKERS})")
          server.serve_forever()

  # â”€â”€ Review prompt template â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - path: /opt/pr-review/prompt.md
    permissions: "0644"
    content: |
      You are reviewing PR #{pr_number} in {repo}.
      Title: {pr_title}
      Description: {pr_body}

      Review this diff. Be concise and actionable. Focus on:
      1. Bugs, logic errors, edge cases
      2. Security concerns
      3. Missing error handling
      4. Concrete suggestions for improvement

      If the PR looks good, say so briefly. Don't nitpick formatting or style.
      {truncation_note}

      Diff:
      ```
      {diff}
      ```

  # â”€â”€ Auth health check script â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - path: /opt/pr-review/check-auth.sh
    permissions: "0755"
    content: |
      #!/usr/bin/env bash
      set -euo pipefail

      set -a
      source /opt/pr-review/.env
      set +a

      ALERT_REPO="${ALERT_REPO:-}"
      ISSUE_TITLE="ğŸ”‘ PR Review Agent: Claude auth expired"

      check_claude() {
          timeout 30 claude -p "Reply with OK" --output-format text 2>/dev/null \
              | grep -qi "ok"
      }

      check_gh() {
          gh auth status &>/dev/null
      }

      alert() {
          local tool="$1"
          echo "AUTH FAILURE: $tool auth is invalid"

          # Don't alert if no repo configured
          if [[ -z "$ALERT_REPO" ]]; then
              echo "ALERT_REPO not set, cannot create issue"
              exit 1
          fi

          # Don't spam â€” check for existing open issue
          existing=$(gh issue list --repo "$ALERT_REPO" \
              --search "$ISSUE_TITLE" --state open --json number --jq 'length' 2>/dev/null || echo "0")

          if [[ "$existing" != "0" ]]; then
              echo "Alert issue already open, skipping"
              exit 0
          fi

          gh issue create --repo "$ALERT_REPO" \
              --title "$ISSUE_TITLE" \
              --body "$(cat <<EOF
      ## Auth Expired

      The PR review agent on \`$(hostname)\` detected that **${tool}** authentication
      has expired and needs to be renewed.

      ### How to fix

      SSH into the server and run:

      \`\`\`bash
      # If Claude auth expired:
      sudo -u review claude

      # If GitHub auth expired:
      sudo -u review gh auth login
      \`\`\`

      Then verify:
      \`\`\`bash
      sudo -u review /opt/pr-review/check-auth.sh
      \`\`\`

      This issue was created automatically. Close it once resolved.

      ---
      *Server: $(hostname) | Time: $(date -u '+%Y-%m-%d %H:%M UTC')*
      EOF
      )" \
              --label "ops" 2>/dev/null || echo "Failed to create alert issue"

          exit 1
      }

      echo "Checking GitHub CLI auth..."
      check_gh || alert "GitHub CLI (gh)"

      echo "Checking Claude CLI auth..."
      check_claude || alert "Claude CLI"

      echo "All auth checks passed."

  # â”€â”€ Systemd service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - path: /etc/systemd/system/pr-review.service
    content: |
      [Unit]
      Description=GitHub PR Review Agent
      After=network.target caddy.service
      Wants=caddy.service

      [Service]
      Type=simple
      User=review
      Group=review
      WorkingDirectory=/opt/pr-review
      EnvironmentFile=/opt/pr-review/.env
      Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/review/.npm-global/bin
      ExecStart=/usr/bin/python3 /opt/pr-review/agent.py
      Restart=always
      RestartSec=10

      # Security hardening
      NoNewPrivileges=yes
      ProtectSystem=strict
      ReadWritePaths=/opt/pr-review
      PrivateTmp=yes
      ProtectHome=no
      ProtectKernelTunables=yes
      ProtectKernelModules=yes
      ProtectControlGroups=yes
      RestrictNamespaces=yes
      RestrictSUIDSGID=yes
      MemoryDenyWriteExecute=no

      [Install]
      WantedBy=multi-user.target

  # â”€â”€ Auth check timer (every 30 min) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - path: /etc/systemd/system/pr-review-auth-check.service
    content: |
      [Unit]
      Description=PR Review Agent auth health check

      [Service]
      Type=oneshot
      User=review
      Group=review
      EnvironmentFile=/opt/pr-review/.env
      Environment=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/review/.npm-global/bin
      ExecStart=/opt/pr-review/check-auth.sh

  - path: /etc/systemd/system/pr-review-auth-check.timer
    content: |
      [Unit]
      Description=Run PR Review auth check every 30 minutes

      [Timer]
      OnBootSec=5min
      OnUnitActiveSec=30min
      RandomizedDelaySec=60

      [Install]
      WantedBy=timers.target

  # â”€â”€ Caddy reverse proxy config (written in runcmd after caddy install) â”€â”€

runcmd:
  # â”€â”€ Install Node.js (for Claude Code) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - curl -fsSL https://deb.nodesource.com/setup_22.x | bash -
  - apt-get install -y nodejs
  - npm install -g @anthropic-ai/claude-code

  # â”€â”€ Install GitHub CLI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg -o /usr/share/keyrings/githubcli-archive-keyring.gpg
  - chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
  - echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" > /etc/apt/sources.list.d/github-cli.list
  - apt-get update && apt-get install -y gh

  # â”€â”€ Install Caddy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
  - curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
  - chmod o+r /usr/share/keyrings/caddy-stable-archive-keyring.gpg
  - chmod o+r /etc/apt/sources.list.d/caddy-stable.list
  - apt-get update && apt-get install -y caddy

  # â”€â”€ Write Caddy config (after install so it doesn't get overwritten) â”€â”€
  - |
    cat > /etc/caddy/Caddyfile <<'CADDYEOF'
    {
        auto_https off
    }

    :443 {
        tls /etc/caddy/certs/origin.pem /etc/caddy/certs/origin-key.pem
        reverse_proxy 127.0.0.1:8080
        request_body {
            max_size 5MB
        }
        log {
            output stdout
            format json
        }
    }

    :8081 {
        respond /ping "pong" 200
        reverse_proxy /health 127.0.0.1:8080
    }
    CADDYEOF

  # â”€â”€ Create service user â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - useradd -r -m -s /bin/bash review

  # â”€â”€ Generate secrets and write env file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - |
    WEBHOOK_SECRET=$(openssl rand -hex 32)
    {
      echo "GITHUB_WEBHOOK_SECRET=${WEBHOOK_SECRET}"
      echo "REVIEW_WORKDIR=/opt/pr-review/workspace"
      echo "MAX_WORKERS=4"
      echo "PORT=8080"
      echo "ALERT_REPO="
    } > /opt/pr-review/.env

  # â”€â”€ Set up directories and permissions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - mkdir -p /opt/pr-review/workspace
  - mkdir -p /etc/caddy/certs
  - chown -R review:review /opt/pr-review
  - chmod 600 /opt/pr-review/.env

  # â”€â”€ Firewall â€” only SSH and HTTPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - ufw allow OpenSSH
  - ufw allow 443/tcp
  - ufw --force enable

  # â”€â”€ Enable services (don't start pr-review yet â€” needs auth) â”€â”€
  - systemctl daemon-reload
  - systemctl enable caddy
  - systemctl enable pr-review
  - systemctl enable pr-review-auth-check.timer
  - |
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "  SETUP COMPLETE â€” manual steps remaining:"
    echo ""
    echo "  1. Add Cloudflare Origin CA cert:"
    echo "       /etc/caddy/certs/origin.pem"
    echo "       /etc/caddy/certs/origin-key.pem"
    echo "     Then: systemctl restart caddy"
    echo ""
    echo "  2. Authenticate:"
    echo "       sudo -u review gh auth login"
    echo "       sudo -u review claude"
    echo ""
    echo "  3. Edit /opt/pr-review/.env:"
    echo "       Set ALERT_REPO=your-org/repo-name"
    echo ""
    echo "  4. Start the agent:"
    echo "       systemctl start pr-review"
    echo "       systemctl start pr-review-auth-check.timer"
    echo ""
    echo "  5. Configure org webhook â†’ https://your-domain/webhook"
    echo "       Secret: $(cat /opt/pr-review/.env | grep WEBHOOK_SECRET | cut -d= -f2)"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
